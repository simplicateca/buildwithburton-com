<?php
/**
 * SiteModule - Normalize Block Twig Extension
 *
 * Splice any fragment block types into the block array.
 *
 * Merges the `settings` objects from the block variant, layout, and theme
 * fields (SelectPlus) into a single `settings` object.
 *
 * SelectPlus - https://github.com/simplicateca/craft-selectplus-field
 */

/**------------------------------------------------------------------------------------/

    BuilderBase() is responsible for 3 primary things:

 1) Explode Fragment blocks into individual blocks and splice them into the block list.

 2) Merge any provided `settings` with the ones generated by the primary attribute
    fields (i.e. variant, layout, and theme. Since those three fields are typically
    SelectPlus fields, they provide both a `value` and an array of related `settings`.

    Any related attribute settings are merged into the block-level `settings`.

 -> `craftcms/templates/_config`
 -> https://github.com/simplicateca/craft-selectplus-field


 3) Normalize the object passed to each `block.<entrytype>.twig` template.


    Normalized Block Format
/**------------------------------------------------------------------------------------/
    Looping though a Matrix field typically yields individual EntryTypes objects.
 -> https://craftcms.com/docs/5.x/reference/element-types/entries.html#entry-types

    However, since we want to pass-through an additional `settings` array with each
    block in our builder, we need create our own slightly modify data structure versus
    what gets returned from something like `entry.matrixBuilder.all()`

    For non-manual blocks, we use the `fieldValues` property of the block Entry to
    give us access to all custom field values.

 -> https://docs.craftcms.com/api/v5/craft-base-element.html#property-fieldvalues

    We include our `settings` property and also store to original block entry object
    in `_block` so that the Twig templates never lose access to the full object.

    A normalized Image Block record might would look like this:
/**------------------------------------------------------------------------------------/
    {
        text    : "<p>Html content from rich text editor</p>", // or <HtmlFieldData>
        images  : <AssetQueryObject>
        variant : <SelectPlusFieldObject>,
        layout  : <SelectPlusFieldObject>,
        theme   : <SelectPlusFieldObject>,
        settings: {
            _prev     : { ... } // previous block settings array
            _next     : { ... } // next block settings array
            variant   : 'simple',
            layout    : 'copyAbove',
            theme     : 'base',
            section   : 'pages',
            builder   : 'default',
            blocktype : 'image',
            blockslug : 'image-block',
            blocktitle: ''
            ...etc
        },
        '_block'   : <MatrixEntryObject>,
        '_fragment': <MatrixEntryObject>,
        '_normal'  : true,
    }
/**----------------------------------------------------------------------------------**/
namespace modules\sitemodule\twigextensions;

use Craft;
use Twig\TwigFunction;
use Twig\Extension\AbstractExtension;

class BuilderBaseTwig extends AbstractExtension {
    public function getFunctions() : array {
        return [
            new TwigFunction( 'BuilderBase', [ $this, 'BuilderBase' ] ),
            new TwigFunction( 'builderbase', [ $this, 'BuilderBase' ] ),
        ];
    }


    // Basically a series of maps / transforms against the input list of blocks.
    //
    // Pretty sure there's an FP pattern here, but i'm not sure what it is or how to
    // implement it in PHP.
    //
    // Choosing readability over DRY, each step in the chain is responsible for checking
    // to see if it's already dealing with a normalized block or not.
    public function BuilderBase( $matrixblocks = [], $builderSettings = [] ) : array
    {
        // 1) Splice in Fragments
        $blocks = [];
        foreach( $matrixblocks as $block ) {

            // Already normalized?
            if( $this->_isnormal( $block ) ) {
                $blocks[] = $block;
                continue;
            }

            // _fragments() will return null if the block isn't a fragment. otherwise it
            // returns an array of blocks ready to be normalized.
            if( $fragments = $this->_fragments( $block, $builderSettings ) ) {
                array_push( $blocks, ...$fragments );
                continue;
            }

            // $block['settings'] will only exist on hand-coded/manually-inserted blocks.
            // Since those are unlikely to have their own primary attribute fields, we
            // expect `settings` to already have everything needed for rendering.
            $settings = $builderSettings;
            if( is_array( $block ) && isset( $block['settings'] ) && is_array( $block['settings'] ) ) {
                $settings = array_merge( $settings, $block['settings'] );
                unset( $block['settings'] );
            }

            $blocks[] = [ 'block' => $block, 'settings' => $settings ];
        }


        // 2) Primary Attribute Fields
        // Adds  data from variant, layout, theme fields (if they exist)
        $blocks = array_map( function( $b ) {
            return $this->_attributes( $b );
        }, $blocks );


        // 3) Sibling Therapy (Part 1)
        // Simplifies theme (and Fragment theme) inheritance between adjacent blocks.
        $blocks = $this->_themes( $blocks );


        // 4) Normification
        $blocks = $this->_normify( $blocks );


        // 5) Sibling Therapy (Part 2)
        // Simplify access to next & prev block `settings` data for Twig templates.
        return $this->_adjacents( $blocks );

    }


    private function _isnormal( $block = null ) {
        return ( $block && is_array( $block ) && isset( $block['_normal'] ) );
    }


    private function _attributes( $b = null ) : array|null
    {
        // empty?!
        if( !$b || empty( $b ) ) { return null; }

        // check for pre-normalized blocks
        if( $this->_isnormal( $b ) ) { return $b; }

        // check for pre-normalized blocks
        if( !isset($b['block']) || empty($b['block']) ) { return null; }

        // still here? cool .. add custom field values
        $b['fieldData'] = is_object($b['block'])
            ? collect( $b['block']->fieldValues )->all()
            : $b['block'];

        // add some high-level block attributes
        $highlevel = collect([
            'field'      => $this->_field( $b['block'] ),
            'blockslug'  => $this->_slug( $b['block'] ),
            'blocktype'  => $this->_type( $b['block'] ),
            'blocktitle' => $this->_title( $b['block'] ),
            'theme'      => (string) $this->_attrvalue( $b['fieldData'], 'theme' ),
            'layout'     => (string) $this->_attrvalue( $b['fieldData'], 'layout' ),
            'variant'    => (string) $this->_attrvalue( $b['fieldData'], 'variant' ),
        ])->filter(function ($value) {
            return !empty($value);
        })->all();

        $b['settings'] = array_merge(
            ['theme' => 'base', 'layout' => '', 'variant' => ''],
            $b['settings'] ?? [],
            $highlevel
        );

        // add the primary attribute field data
        $b['theme']   = $this->_attrdata( $b['fieldData'], 'theme' );
        $b['layout']  = $this->_attrdata( $b['fieldData'], 'layout' );
        $b['variant'] = $this->_attrdata( $b['fieldData'], 'variant' );

        return $b;
    }


    // Responsible for handling theme inheritence and fragment theme inheritence.
    // details about their immediate siblings `settings` without having to muck about
    // looking forwards or backwards within the array when working in Twig.
    private function _themes( $blocks = [] ) {

        // Get rid of empty shit right off the top
        $blocks = array_filter( $blocks );

        // we'll use this to track details for the last inheritable theme
        $theme = [
            'name'     => 'base',
            'settings' => []
        ];

        // handle theme inheritence and fragment theme inheritence
        foreach( $blocks AS $key => $block ) {

            // keep track of the settings for the last inheritable theme
            if( $block['settings']['theme'] && strtoupper( $block['settings']['theme'] ) != 'INHERIT' ) {
                $theme['name'] = $block['settings']['theme'];
                if( isset( $block['theme'] ) && !empty( $block['theme'] ) ) {
                    $theme['settings'] = $block['theme'];
                }
            }

            // let fragment blocks override the theme of the block(s) it is importing
            if( isset($block['fragment']) && !empty($block['fragment']) ) {
                $fragment = $this->_attributes( $block['fragment'] );
                if( strtoupper( $fragment['settings']['theme'] ) != 'FRAGMENT'  ) {
                    $blocks[$key]['settings']['theme'] = $fragment['settings']['theme'];
                    $blocks[$key]['theme'] = $fragment['theme'];
                }
            }

            // if this block is inheriting the theme from the previous block
            if( isset( $blocks[$key]['settings']['theme'] ) && strtoupper( $blocks[$key]['settings']['theme'] ) == 'INHERIT' ) {
                $blocks[$key]['settings']['theme'] = $theme['name'];
                $blocks[$key]['theme'] = array_merge( $theme['settings'], $blocks[$key]['theme'] ?? [] );
            }
        }

        return $blocks;
    }


    private function _normify( $blocks ) : array
    {
        $normals = [];
        foreach( $blocks AS $block ) {

            if( $this->_isnormal( $block ) ) {
                $normals[] = $block;
                continue;
            }

            // Slam primary attribute field data into the block-level `settings`
            $settings = $block['settings'] ?? [];
            $settings = array_merge( $settings, $block['theme']   ?? [] );
            $settings = array_merge( $settings, $block['layout']  ?? [] );
            $settings = array_merge( $settings, $block['variant'] ?? [] );

            // normalize
            $normals[] = array_merge([
                'settings'  => $settings,
                '_fragment' => $block['fragment'] ?? null,
                '_block'    => $block['block'],
                '_normal'   => true,
            ], $block['fieldData'] ?? [] );
        }

        return $normals;
    }


    // Simplify access to adjacent block settings.
    // ----------------------------------------------------------------------------------
    // Also pre-calculate whether adjacent blocks have matching next/prev themes and/or
    // canvas coverage, which helps with some layout decisions (particularly where to
    // place spacers & transitions). This should be run *AFTER* normify()
    private function _adjacents( $blocks = [] ) : array {
        foreach( $blocks AS $key => $block ) {

            $curr = isset($blocks[$key]['settings']['basetheme'])
                ? $blocks[$key]['settings']['basetheme']
                : $blocks[$key]['settings']['theme'];

            if( $key > 0 && $blocks[$key-1]['settings'] ?? null ) {
                $blocks[$key]['settings']['_prev'] = $blocks[$key-1]['settings'];

                $prev = isset($blocks[$key]['settings']['_prev']['basetheme'])
                    ? $blocks[$key]['settings']['_prev']['basetheme']
                    : $blocks[$key]['settings']['_prev']['theme'];

                $blocks[$key]['settings']['_prev']['match__theme'] = ( $curr == $prev );
            }

            if( $blocks[$key+1]['settings'] ?? null ) {
                $blocks[$key]['settings']['_next'] = $blocks[$key+1]['settings'];

                $next = isset($blocks[$key]['settings']['_next']['basetheme'])
                    ? $blocks[$key]['settings']['_next']['basetheme']
                    : $blocks[$key]['settings']['_next']['theme'];

                $blocks[$key]['settings']['_next']['match__theme'] = ( $curr == $next );
            }
        }

        return $blocks;
    }



    // Helper Functions for Accessing $block data
    // ----------------------------------------------------------------------------------
    // Return the (lowercase) entrytype handle (or 'manual' for assumed manual blocks)
    private function _type( $block ) : string {
        $type = is_object( $block )
            ? $block->type->handle
            : ( isset( $block['type'] ) ? $block['type'] : null );
        return strtolower( $type ?? 'manual' );
    }


    // Returns the block Title field
    private function _title( $block ) : string|null {
        return is_object( $block )
            ? $block->title
            : ( isset( $block['title'] ) ? $block['title'] : null );
    }


    // Gets the field handle for the matrix block we're building
    private function _field( $block ) : string|null {
        return is_object( $block )
            ? $block->field->handle
            : ( isset( $block['field'] ) ? $block['field'] : null );
    }


    // Gets the block slug
    private function _slug( $block ) : string|null {
        return is_object( $block )
            ? ( property_exists($block, 'slug') ? $block->slug : null)
            : ( isset( $block['slug'] ) ? $block['slug'] : null );
    }


    // get the string value of a primary attribute field (theme, layout, variant)
    private function _attrvalue( $values, $attr ) : string|null {
        $value = isset( $values[$attr] )
            ? (string) $values[$attr]
            : '';
        return $value;
    }


    // As the primary attribute fields are typically custom SelectPlus fields, this
    // returns the combined values of any `settings` + `virtuals` values for the field.
    //
    // When building a manual block, these extended field settings typically wouldn't
    // exist. All values needed to render a manual block should be provided directly in
    // that blocks `settings` param.
    private function _attrdata( $values, $attr ) : array|null {
        $result = isset( $values[$attr] )
            ? ( is_object( $values[$attr] ) ? $values[$attr]->settings : [] )
            : ( isset( $values[$attr]['settings'] ) ? $values[$attr]['settings'] : [] );

        return $result;
    }


    // Find all the fragments that exist as part of this block
    // ----------------------------------------------------------------------------------
    // Fragment blocks may contain more than one block and we need to splice them into
    // the block array so that they can be normalized. Luckily fragments can not contain
    // other fragments so we don't have to go recursive on this shit.
    //
    // TODO: Umm.. does Craft 5 with Nested Matrix fields change my opinion of the above?
    private function _fragments( $original, $settings ) : array|null {

        if( $this->_type( $original ) != 'fragment' ) { return null; }

        // this is ugly but it does the trick for now.
        // TODO: could probably do with some eager loading?
        $fragments = $original->fragments->collect()->map( function ( $frag ) {
            return $frag->bodyBuilder->all()
                ?? $frag->sidebarBuilder->all()
                ?? [];
        })->all() ?? [];


        // Pre-normalize(?) Individual Fragments
        // ------------------------------------------------------------------------------
        // Don't forget to set the Entry Owner of the original Fragment block.
        // This is so that we can make sure that the blocks being spliced into the
        // builder array will report as "belonging" to the entry that the original block
        // was created on rather than an Entry in Reusable Content channel.
        $blocks = [];
        foreach( $fragments AS $block ) {
            $block->setOwner( $original->owner );
            $blocks[] = [
                'block'    => $block,
                'fragment' => $original,
                'settings' => $settings
            ];
        }

        return $blocks;
    }
}